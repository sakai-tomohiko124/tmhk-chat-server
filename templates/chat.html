<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>リアルタイムチャット</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        /* モダンな背景デザイン */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            /* 美しいグラデーション背景 */
            background: linear-gradient(135deg, #71b7e6, #9b59b6);
        }
        
        /* サイドバー */
        .sidebar {
            width: 280px;
            flex-shrink: 0;
            /* フロストガラス効果 */
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            color: #fff;
        }
        .sidebar h2, .sidebar h3, .sidebar h4 {
            margin-top: 0; margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        .sidebar-section { margin-bottom: 20px; }
        .chat-list a {
            text-decoration: none; color: #fff; padding: 10px 15px; border-radius: 8px;
            margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center;
            transition: background 0.2s;
        }
        .chat-list a.active { background-color: rgba(255, 255, 255, 0.3); font-weight: bold; }
        .chat-list a:not(.active):hover { background-color: rgba(255, 255, 255, 0.1); }
        .badge { background-color: #e74c3c; color: white; border-radius: 10px; padding: 2px 8px; font-size: 12px; font-weight: bold; }
        .sidebar select, .sidebar button, .sidebar input[type="text"] {
            width: 100%; padding: 8px; border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-sizing: border-box; background: rgba(0,0,0,0.2); color: #fff;
        }
        .sidebar select option { background: #333; }
        .sidebar button { margin-top: 10px; cursor: pointer; }
        .sidebar .btn-primary { background-color: #3498db; border-color: #3498db; }
        .sidebar .btn-secondary { background-color: #95a5a6; border-color: #95a5a6; }
        #online-users-list { font-size: 14px; }

        /* メインチャットエリア */
        .chat-container {
            flex-grow: 1; display: flex; flex-direction: column;
            background: rgba(255, 255, 255, 0.7);
        }
        .header {
            padding: 10px 20px; border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(255, 255, 255, 0.5);
        }
        .chat-title { font-weight: bold; font-size: 20px; color: #333; }
        .header a { color: #2980b9; }

        .chat-window { flex-grow: 1; overflow-y: scroll; padding: 20px; }
        .message { margin-bottom: 15px; display: flex; flex-direction: column; }
        .message.mine { align-items: flex-end; }
        .message.other { align-items: flex-start; }
        .message-bubble { max-width: 70%; padding: 10px 15px; border-radius: 20px; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .message.mine .message-bubble { background: #3498db; color: white; }
        .message.other .message-bubble { background: #fff; color: #333; }
    .unsafe-message { background: linear-gradient(135deg, #ffcccc, #ffe6e6); border: 2px dashed #ff4d4d; color: #660000; transform: rotate(-0.5deg); }
    .follow-btn, .unfollow-btn { padding:4px 6px; margin-right:4px; font-size:12px; border-radius:4px; border: none; cursor:pointer; }
    .follow-btn { background:#2ecc71; color:#fff; }
    .unfollow-btn { background:#e74c3c; color:#fff; }
    /* toast styles */
    .toast { background: rgba(0,0,0,0.85); color: #fff; padding: 8px 12px; margin-top:8px; border-radius:8px; box-shadow: 0 2px 6px rgba(0,0,0,0.3); min-width:200px; display:flex; justify-content:space-between; align-items:center; }
    .toast.success { background: linear-gradient(90deg,#2ecc71,#27ae60); }
    .toast.error { background: linear-gradient(90deg,#e74c3c,#c0392b); }
    .toast button { background: transparent; border: none; color: rgba(255,255,255,0.9); font-size:16px; cursor:pointer; }
    .toast .toast-actions { display:flex; gap:8px; margin-left:12px; }
    .toast .toast-action-btn { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); color: #fff; padding:6px 8px; border-radius:6px; cursor:pointer; font-size:13px; }
    .toast .toast-action-btn:hover { background: rgba(255,255,255,0.12); }
    /* online filter icon buttons */
        .online-filter-btn { background: transparent; border: 1px solid rgba(255,255,255,0.12); color: #fff; padding:6px 8px; border-radius:6px; cursor:pointer; font-size:14px; }
    .online-filter-btn.active { background: rgba(255,255,255,0.18); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }

    /* Focus and accessibility styles */
    :focus { outline: none; }
    :focus-visible { outline: 3px solid rgba(52,152,219,0.6); outline-offset: 2px; border-radius: 8px; }
    button:focus-visible, .online-filter-btn:focus-visible, .sidebar input[type="text"]:focus-visible, select:focus-visible { box-shadow: 0 0 0 3px rgba(52,152,219,0.14); }

    /* Larger tap targets for mobile: ensure comfortable touch size */
    button, .online-filter-btn, .sidebar button, #send_button, #file_label { min-height: 40px; padding: 8px 10px; }

    /* History list: compact layout and truncation to keep everything inside viewport */
    .history-item { display:flex; gap:8px; padding:8px; align-items:center; border-radius:6px; color:inherit; text-decoration:none; }
    .history-item .history-thumb { flex: 0 0 40px; width:40px; height:40px; }
    .history-item > div { overflow: hidden; }
    .history-item strong, .history-item small, .history-item span { display:block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .history-item small { color: #ddd; font-size: 12px; max-width: 180px; }

    /* Online users: compact and truncated entries */
    #online-users-list div { padding:6px 4px; border-radius:6px; margin-bottom:4px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

    /* Ensure message bubbles don't overflow on very narrow screens */
    .message-bubble { word-break: break-word; }

    /* Small tweaks for invite input */
    #invite-link-input { width:100%; box-sizing:border-box; padding:8px; border-radius:6px; }
        .message-info { font-size: 0.8em; color: #555; margin-top: 5px; }
        .message-info .username { font-weight: bold; }
        .message-content img, .message-content video { max-width: 100%; max-height: 250px; border-radius: 10px; display: block; }
        .message-content a { color: inherit; }
        .input-area { padding: 10px 20px; border-top: 1px solid rgba(0, 0, 0, 0.1); background: rgba(255, 255, 255, 0.5); }
        .input-area form { display: flex; align-items: center; }
        #message_input { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 20px; margin-right: 10px; }
        #file_input { display: none; }
        #file_label { padding: 8px 12px; background-color: #95a5a6; color: white; border-radius: 50%; cursor: pointer; margin-right: 10px; font-size: 20px; line-height: 1; }
        #send_button { padding: 10px 20px; background-color: #3498db; color: white; border: none; border-radius: 20px; cursor: pointer; }
        #typing-status { height: 20px; color: #555; font-style: italic; font-size: 14px; padding-left: 10px; }

        /* Responsive: mobile-first. Sidebar collapses into drawer on small screens. */
        @media (max-width: 900px) {
            .sidebar { position: fixed; left: 0; top: 0; bottom: 0; width: 78%; max-width: 360px; transform: translateX(-110%); transition: transform 0.25s ease; z-index: 1200; padding-top: 60px; }
            .sidebar.open { transform: translateX(0); }
            body.mobile-sidebar-open { overflow: hidden; }
            /* show toggle button in header */
            #sidebar-toggle { display: inline-block; margin-right: 10px; }
            .chat-container { margin-left: 0; }
            .chat-window { padding: 12px; }
            /* make history and online lists more compact */
            .sidebar { width: 78%; padding: 16px; }
            .history-thumb { width:36px; height:36px; }
            .message-bubble { max-width: 88%; }
        }

        @media (max-width: 480px) {
            .sidebar { width: 86%; max-width: 320px; }
            .message-content img, .message-content video { max-height: 180px; }
            #file_label { font-size: 18px; padding: 6px 10px; }
            .online-filter-btn { padding:6px 6px; font-size:13px; }
            .sidebar select, .sidebar button, .sidebar input[type="text"] { padding: 6px; font-size: 14px; }
        }

        /* Overlay when sidebar open on small screens */
        #sidebar-overlay { position: fixed; left:0; top:0; right:0; bottom:0; background: rgba(0,0,0,0.4); z-index: 1100; display:none; }
        #sidebar-overlay.visible { display:block; }
    </style>
</head>
<body>
    <!-- Toast container -->
    <div id="toast-container" style="position:fixed; right:20px; bottom:20px; z-index:9999;"></div>

    <div class="sidebar">
        <div class="sidebar-section">
            <h2>チャット</h2>
            <div class="chat-list" id="chat-list">
                <a href="{{ url_for('chat', room=GROUP_ROOM) }}" class="{% if current_room == GROUP_ROOM %}active{% endif %}" data-room="{{ GROUP_ROOM }}">
                    <span>全員のグループチャット</span>
                    {% if unread_counts.get(GROUP_ROOM) %}<span class="badge">{{ unread_counts[GROUP_ROOM] }}</span>{% endif %}
                </a>
            </div>
        </div>
        <div class="sidebar-section">
            <h3>友達を招待</h3>
            <input type="text" value="{{ url_for('index', invite=username, _external=True) }}" id="invite-link-input" readonly>
            <button class="btn-secondary" id="copy-invite-link-btn">リンクをコピー</button>
        </div>
        <div class="sidebar-section">
            <h3>新しい個人チャット</h3>
            <form action="{{ url_for('start_dm') }}" method="POST">
                <div style="margin-bottom:8px; display:flex; gap:6px; align-items:center;">
                    <label style="color:#fff; font-size:13px;">候補:</label>
                    <div id="partner-source" style="display:flex; gap:6px;" role="tablist" aria-label="候補ソース">
                        <button type="button" class="online-filter-btn {% if initial_partner_source == 'online' %}active{% endif %}" data-source="online" title="オンラインのみ" aria-pressed="{% if initial_partner_source == 'online' %}true{% else %}false{% endif %}">🟢 <span style="font-size:11px; margin-left:6px; color:#fff;">オンライン</span></button>
                        <button type="button" class="online-filter-btn {% if initial_partner_source == 'history' %}active{% endif %}" data-source="history" title="履歴ベース" aria-pressed="{% if initial_partner_source == 'history' %}true{% else %}false{% endif %}">📜 <span style="font-size:11px; margin-left:6px; color:#fff;">履歴</span></button>
                        {% if is_admin %}
                            <button type="button" class="online-filter-btn {% if initial_partner_source == 'all' %}active{% endif %}" data-source="all" title="全ユーザー" aria-pressed="{% if initial_partner_source == 'all' %}true{% else %}false{% endif %}">🔎 <span style="font-size:11px; margin-left:6px; color:#fff;">全員</span></button>
                        {% endif %}
                    </div>
                </div>
                <select name="partner" id="partner_select" required>
                    <option value="">-- 会話相手を選択 --</option>
                    {% for p in partner_candidates %}
                        <option value="{{ p }}">{{ p }}</option>
                    {% endfor %}
                </select>
                <button type="submit" class="btn-primary">会話を開始</button>
            </form>
        </div>
        <div class="sidebar-section">
            <h4>オンライン中のユーザー</h4>
                <div style="margin-bottom:8px; color:#fff; display:flex; gap:8px; align-items:center;">
                <span style="font-size:13px;">表示:</span>
                <div id="online-filter" role="tablist" aria-label="オンライン表示フィルタ">
                    <button class="online-filter-btn {% if initial_filter == 'followers' %}active{% endif %}" data-filter="followers" title="フォロワー" aria-pressed="{% if initial_filter == 'followers' %}true{% else %}false{% endif %}">👥 <span style="font-size:11px; margin-left:6px; color:#fff;">フォロワー</span></button>
                    <button class="online-filter-btn {% if initial_filter == 'following' %}active{% endif %}" data-filter="following" title="お気に入り" aria-pressed="{% if initial_filter == 'following' %}true{% else %}false{% endif %}">⭐ <span style="font-size:11px; margin-left:6px; color:#fff;">お気に入り</span></button>
                    <button class="online-filter-btn {% if initial_filter == 'all' %}active{% endif %}" data-filter="all" title="全員" aria-pressed="{% if initial_filter == 'all' %}true{% else %}false{% endif %}">🌐 <span style="font-size:11px; margin-left:6px; color:#fff;">全員</span></button>
                </div>
            </div>
            {% if is_admin %}
                <div id="online-users-list"></div>
            {% else %}
                <div id="online-users-list">（管理者以外はフィルタで表示を切替できます）</div>
            {% endif %}
            <h4 style="margin-top:12px;">履歴</h4>
            <div style="margin-bottom:8px;">
                <input type="text" id="history-search" placeholder="履歴を検索..." style="width:100%; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.2); background:rgba(0,0,0,0.15); color:#fff; box-sizing:border-box;">
            </div>
            <div id="history-list" style="max-height:220px; overflow:auto;">
                {% for h in users_with_history %}
                    <a href="{{ url_for('chat', room=h.room) }}" class="history-item" data-room="{{ h.room }}" data-unread="{{ h.unread_count }}" data-last-ts="{{ h.last_timestamp }}">
                        <div style="display:flex; align-items:center; justify-content:space-between;">
                            <div style="display:flex; align-items:center;">
                                <div class="history-thumb" style="width:40px; height:40px; background:#ddd; border-radius:6px; overflow:hidden; margin-right:8px; display:flex; align-items:center; justify-content:center;">
                                    {% if h.last_file_type == 'image' %}
                                        <img src="{{ url_for('uploaded_file', filename=h.last_file_path) }}" style="width:100%; height:100%; object-fit:cover;" />
                                    {% elif h.last_file_type == 'video' %}
                                        <video src="{{ url_for('uploaded_file', filename=h.last_file_path) }}" style="width:100%; height:100%; object-fit:cover;" muted></video>
                                    {% else %}
                                        <span style="font-size:12px; color:#333;">{{ h.username[:1] }}</span>
                                    {% endif %}
                                </div>
                                <div style="display:flex; flex-direction:column;">
                                    <strong style="color:#fff;">{{ h.username }}</strong>
                                    {% if not is_admin %}
                                        <div style="font-size:12px; margin-top:4px;">
                                            <button class="follow-btn" data-username="{{ h.username }}">フォロー</button>
                                            <button class="unfollow-btn" data-username="{{ h.username }}">フォロー解除</button>
                                        </div>
                                    {% endif %}
                                    <small style="color:#ddd;">{{ h.last_excerpt or (h.last_file_type and '[' ~ h.last_file_type ~ ']') or '' }}</small>
                                </div>
                            </div>
                            <div>
                                {% if h.unread_count and h.unread_count > 0 %}<span class="badge">{{ h.unread_count }}</span>{% endif %}
                            </div>
                        </div>
                    </a>
                {% endfor %}
            </div>
            <div style="display:flex; justify-content:space-between; margin-top:8px;">
                <button id="history-prev" class="btn-secondary">前</button>
                <div id="history-page-info" style="color:#fff; align-self:center;">1/1</div>
                <button id="history-next" class="btn-secondary">次</button>
            </div>
        </div>
    </div>

    <div class="chat-container">
        <header class="header">
            <div class="chat-title">
                {% if current_room == GROUP_ROOM %}グループチャット{% else %}{{ chat_partner }} さんとの会話{% endif %}
            </div>
            <div>
                <button id="sidebar-toggle" aria-label="サイドバーを開く" style="display:none;">☰</button>
                <span style="margin-right: 20px; color: #333;">ようこそ, <span id="current-user" data-is-admin="{{ '1' if is_admin else '0' }}" data-max-bytes="{{ MAX_CONTENT_BYTES }}" data-chunk-size="{{ CHUNK_SIZE }}">{{ username }}</span> さん</span>
                {% if is_admin %}<a href="{{ url_for('admin_panel') }}" style="margin-right: 20px;">管理者パネル</a>{% endif %}
                <a href="{{ url_for('logout') }}">ログアウト</a>
            </div>
        </header>

        <main id="chat-window" class="chat-window">
            {% for msg in messages %}
            <div class="message {% if msg.username == username %}mine{% else %}other{% endif %}">
                <div class="message-bubble {% if msg.safe is defined and msg.safe == 0 %}unsafe-message{% endif %}">
                    <div class="message-content">
                        {% if msg.message %}{{ msg.message }}{% elif msg.file_path %}
                            {% if msg.file_type == 'image' %}<img src="{{ url_for('uploaded_file', filename=msg.file_path) }}" alt="画像">
                            {% elif msg.file_type == 'video' %}<video src="{{ url_for('uploaded_file', filename=msg.file_path) }}" controls></video>
                            {% elif msg.file_type == 'pdf' %}<a href="{{ url_for('uploaded_file', filename=msg.file_path) }}" target="_blank">📄 [PDFファイル: {{ msg.file_path }}]</a>
                            {% endif %}
                        {% endif %}
                    </div>
                </div>
                <div class="message-info">
                    <span class="username">{{ msg.username }}</span> - <span class="timestamp">{{ msg.timestamp_formatted }}</span>
                </div>
            </div>
            {% endfor %}
        </main>
        
        <footer class="input-area">
            <div id="typing-status"></div>
            {% if current_room == GROUP_ROOM and not is_admin %}
                <p style="text-align: center; color: #555; width: 100%;">グループチャットは管理者のみが送信できます。</p>
            {% else %}
                <form id="message-form">
                    <input type="text" id="message_input" placeholder="メッセージを入力..." autocomplete="off">
                    <label for="file_input" id="file_label" title="ファイルを添付">+</label>
                    <input type="file" id="file_input" accept="image/*,video/*,application/pdf" multiple>
                    <button type="submit" id="send_button">送信</button>
                    <!-- ファイル添付の操作案内 -->
                    <div id="file-help" style="margin-top:8px; color:#555; font-size:0.9em;">
                        <span id="file-help-text">ファイルを添付するには「+」をクリックしてファイルを選択し、選択後に「送信」を押してください。 (同時に送れるのは最大3件) 送信可能な1ファイルの上限はページ読み込み時に表示されます。</span>
                        <div id="selected-files" style="margin-top:6px;"></div>
                        <div id="upload-status" style="margin-top:6px; color:#333;"></div>
                        <div id="max-bytes-display" style="margin-top:6px; color:#333; font-size:0.9em;"></div>
                    </div>
                </form>
            {% endif %}
        </footer>
    </div>

    <div id="sidebar-overlay"></div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const socket = io();
        const chatWindow = document.getElementById('chat-window');
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message_input');
        const fileInput = document.getElementById('file_input');
        const typingStatus = document.getElementById('typing-status');
    const currentUserEl = document.getElementById('current-user');
    const currentUser = currentUserEl.textContent;
        const currentRoom = "{{ current_room }}";
        
        chatWindow.scrollTop = chatWindow.scrollHeight;
        // show human-readable max file size
        try {
            const maxBytes = parseInt(currentUserEl.dataset.maxBytes || '0', 10);
            function human(n){
                const units=['B','KB','MB','GB','TB'];
                let idx=0; while(n>=1024 && idx<units.length-1){ n/=1024; idx++; } return n.toFixed(2)+units[idx];
            }
            if (maxBytes>0){ document.getElementById('max-bytes-display').textContent = `1ファイルあたりの上限: ${human(maxBytes)}`; }
        } catch(e){}
        
        socket.on('connect', function() { socket.emit('join_room', { room: currentRoom }); socket.emit('mark_as_read', { room: currentRoom }); });
        // toast helper with ttl, close button, hover pause and max stack
        const TOAST_MAX = 5;
        // showToast now accepts actions: [{ label: '元に戻す', href: '/undo', onClick: function }, ...]
        function showToast(message, type='', ttl=4000, actions){
            const container = document.getElementById('toast-container');
            if(!container) return;
            // enforce max
            while(container.children.length >= TOAST_MAX){ container.firstChild.remove(); }
            const t = document.createElement('div'); t.className = 'toast ' + (type||'');
            const text = document.createElement('div'); text.textContent = message; t.appendChild(text);

            // action buttons container
            if (Array.isArray(actions) && actions.length > 0) {
                const actionsWrap = document.createElement('div'); actionsWrap.className = 'toast-actions';
                actions.forEach((act, idx) => {
                    const btn = document.createElement('button'); btn.className = 'toast-action-btn'; btn.textContent = act.label || ('Action ' + (idx+1));
                    // if href provided, make it behave like a link
                    if (act.href) {
                        btn.addEventListener('click', (ev) => { ev.preventDefault(); window.location.href = act.href; });
                    }
                    // onClick callback
                    if (typeof act.onClick === 'function') {
                        btn.addEventListener('click', (ev) => { try { act.onClick(ev, t); } catch(e){ console.error('toast action error', e); } });
                    }
                    actionsWrap.appendChild(btn);
                });
                t.appendChild(actionsWrap);
            }

            const close = document.createElement('button'); close.textContent='×'; close.style.marginLeft='8px'; close.style.background='transparent'; close.style.border='none'; close.style.color='white'; close.style.fontSize='16px'; close.style.cursor='pointer';
            close.addEventListener('click', ()=>{ clearTimers(); t.remove(); });
            t.appendChild(close);

            let removed = false;
            let hideTimer = null;
            function clearTimers(){ if(hideTimer){ clearTimeout(hideTimer); hideTimer=null; } }
            function scheduleHide(delay){ clearTimers(); hideTimer = setTimeout(()=>{ if(!removed){ t.style.transition='opacity 0.4s'; t.style.opacity='0'; setTimeout(()=>{ if(!removed){ removed=true; t.remove(); } },450); } }, delay); }

            t.addEventListener('mouseenter', ()=>{ clearTimers(); });
            t.addEventListener('mouseleave', ()=>{ scheduleHide(2000); });

            container.appendChild(t);
            // show
            t.style.opacity = '0';
            setTimeout(()=>{ t.style.opacity='1'; }, 10);
            scheduleHide(ttl);
            return t; // return element so caller can manipulate if needed
        }
        socket.on('receive_offline_messages', function(messages) { messages.forEach(function(msg) { renderMessage(msg); }); chatWindow.scrollTop = chatWindow.scrollHeight; });
        socket.on('new_message', function(msg) { renderMessage(msg); chatWindow.scrollTop = chatWindow.scrollHeight; });
        // cache for online/follow information
        let ONLINE_STATUS_CACHE = { online: [], followers: [], following: [] };

        async function refreshOnlineStatus() {
            try {
                const resp = await fetch('/online_status');
                const j = await resp.json();
                ONLINE_STATUS_CACHE = j || { online: [], followers: [], following: [] };
                applyOnlineFilterAndRender();
                // also update partner select using the 'online' list as base
                updatePartnerSelect(ONLINE_STATUS_CACHE.online || []);
            } catch (e) {
                console.error('failed to fetch online_status', e);
            }
        }

        socket.on('update_user_list', function(users) { 
            // when server emits update, refresh our richer online status
            refreshOnlineStatus(); 
        });
        socket.on('user_typing', function(data) { typingStatus.textContent = `${data.username} が入力中です...`; setTimeout(() => { if (typingStatus.textContent === `${data.username} が入力中です...`) { typingStatus.textContent = ''; } }, 3000); });
        socket.on('file_upload_result', function(payload) {
            const helpText = document.getElementById('file-help-text');
            if (!helpText) return;
            if (payload.status === 'success') {
                helpText.textContent = `ファイル ${payload.filename} (${Math.round(payload.size/1024)} KB) をアップロードしました。`;
                // show toast with a '詳細を見る' action that opens the uploaded file in a new tab
                try {
                    showToast(`ファイル ${payload.filename} をアップロードしました。`, 'success', 6000, [
                        { label: '詳細を見る', href: `/uploads/${encodeURIComponent(payload.filename)}` }
                    ]);
                } catch(e){}
            } else {
                helpText.textContent = `アップロード失敗: ${payload.reason}`;
            }
            setTimeout(() => { helpText.textContent = 'ファイルを添付するには「+」をクリックしてファイルを選択し、選択後に「送信」を押してください。 (同時に送れるのは最大3件)'; }, 4000);
        });
        socket.on('update_history', function(payload) {
            // payload: { room, participants: [a,b], unread: { username: count }, followers: {a: [...], b: [...] } }
            const current = document.getElementById('current-user').textContent;
            // find the other participant
            const other = payload.participants.find(p => p !== current);
            if (!other) return;
            const historyList = document.getElementById('history-list');
            if (!historyList) return;

            // Determine if current user follows the other (server sent followers lists)
            let allowed = true; // default allow
            if (payload.followers) {
                // payload.followers is an object mapping participant -> array of followers
                const followersOfOther = payload.followers[other] || [];
                // if current is in followersOfOther, it means current follows 'other'
                allowed = followersOfOther.includes(current);
            }
            // if not allowed (not following) and user didn't enable show_all via query param, skip updating history
            const urlParams = new URLSearchParams(window.location.search);
            if (!allowed && urlParams.get('show_all') !== '1') return;

            // check if an item for this user already exists
            let existing = Array.from(historyList.querySelectorAll('.history-item')).find(el => el.textContent.trim().startsWith(other));
            const unreadCount = (payload.unread && payload.unread[other]) ? payload.unread[other] : 0;
            const room = payload.room;
            if (existing) {
                // update unread badge
                let badge = existing.querySelector('.badge');
                if (unreadCount > 0) {
                    if (!badge) {
                        badge = document.createElement('span'); badge.className = 'badge'; badge.textContent = unreadCount; existing.appendChild(badge);
                    } else {
                        badge.textContent = unreadCount;
                    }
                } else {
                    if (badge) badge.remove();
                }
                // update data attributes
                existing.dataset.unread = unreadCount;
                if (payload.last_timestamp) existing.dataset.lastTs = payload.last_timestamp.replace('T',' ');
            } else {
                // create new history item
                const a = document.createElement('a');
                a.href = `/chat/${room}`;
                a.className = 'history-item';
                a.dataset.room = room;
                a.innerHTML = `<span>${other}</span>`;
                if (unreadCount > 0) {
                    const b = document.createElement('span'); b.className = 'badge'; b.textContent = unreadCount; a.appendChild(b);
                }
                // insert at top to reflect recency/unread priority
                historyList.insertBefore(a, historyList.firstChild);
            }
            // when updated or created, set last_ts attr and then sort the whole history list
            if (payload.last_timestamp) {
                const el = existing || historyList.querySelector(`.history-item[href$="${room}"]`);
                if (el) el.dataset.lastTs = payload.last_timestamp.replace('T',' ');
            }
            sortHistoryList();
        });

        // --- History search & pagination ---
        const HISTORY_PAGE_SIZE = 10;
        let historyCurrentPage = 1;

        function collectHistoryItems() {
            const list = document.getElementById('history-list');
            if (!list) return [];
            return Array.from(list.querySelectorAll('.history-item'));
        }

        function renderHistoryPage(items, page) {
            const list = document.getElementById('history-list');
            if (!list) return;
            list.innerHTML = '';
            const start = (page - 1) * HISTORY_PAGE_SIZE;
            const pageItems = items.slice(start, start + HISTORY_PAGE_SIZE);
            pageItems.forEach(i => list.appendChild(i));
            const info = document.getElementById('history-page-info');
            const totalPages = Math.max(1, Math.ceil(items.length / HISTORY_PAGE_SIZE));
            info.textContent = `${page}/${totalPages}`;
        }

        function applyHistoryFilterAndPagination() {
            const q = document.getElementById('history-search').value.trim().toLowerCase();
            const allItems = sortHistoryItemsForFilter();
            const filtered = allItems.filter(i => i.textContent.toLowerCase().includes(q));
            historyCurrentPage = Math.min(historyCurrentPage, Math.max(1, Math.ceil(filtered.length / HISTORY_PAGE_SIZE)));
            renderHistoryPage(filtered, historyCurrentPage || 1);
        }

        function sortHistoryItemsForFilter() {
            const items = collectHistoryItems();
            items.sort((a,b) => {
                const ua = parseInt(a.dataset.unread || '0', 10);
                const ub = parseInt(b.dataset.unread || '0', 10);
                if (ua !== ub) return ub - ua;
                const ta = a.dataset.lastTs ? new Date(a.dataset.lastTs) : new Date(0);
                const tb = b.dataset.lastTs ? new Date(b.dataset.lastTs) : new Date(0);
                return tb - ta;
            });
            return items;
        }

        document.getElementById('history-search').addEventListener('input', function() { historyCurrentPage = 1; applyHistoryFilterAndPagination(); });
        document.getElementById('history-prev').addEventListener('click', function() { historyCurrentPage = Math.max(1, historyCurrentPage - 1); applyHistoryFilterAndPagination(); });
        document.getElementById('history-next').addEventListener('click', function() { historyCurrentPage = historyCurrentPage + 1; applyHistoryFilterAndPagination(); });

        // initialize pagination view
        applyHistoryFilterAndPagination();

        function sortHistoryList() {
            const historyList = document.getElementById('history-list');
            if (!historyList) return;
            const items = Array.from(historyList.querySelectorAll('.history-item'));
            items.sort((a,b) => {
                const ua = parseInt(a.dataset.unread || '0', 10);
                const ub = parseInt(b.dataset.unread || '0', 10);
                if (ua !== ub) return ub - ua; // more unread first
                const ta = a.dataset.lastTs ? new Date(a.dataset.lastTs) : new Date(0);
                const tb = b.dataset.lastTs ? new Date(b.dataset.lastTs) : new Date(0);
                return tb - ta; // newer first
            });
            // Reattach in sorted order
            items.forEach(i => historyList.appendChild(i));
        }
        
        if (messageForm) {
            messageForm.addEventListener('submit', async function(e) {
                e.preventDefault();
                const messageText = messageInput.value.trim();
                const files = fileInput.files;

                if (messageText) {
                    socket.emit('send_message', { 'message': messageText, 'room': currentRoom });
                    messageInput.value = '';
                }
                    if (files.length > 0) {
                    if (files.length > 3) {
                        showToast('一度に送信できるファイルは3つまでです。', 'error');
                        fileInput.value = '';
                        return;
                    }
                        // client-side size pre-check
                        const maxBytes = parseInt(document.getElementById('current-user').dataset.maxBytes || '0', 10);
                        const chunkSize = parseInt(document.getElementById('current-user').dataset.chunkSize || '0', 10) || 5 * 1024 * 1024;
                        const uploadStatusDiv = document.getElementById('upload-status');
                        uploadStatusDiv.innerHTML = '';
                        document.getElementById('file-help-text').textContent = 'ファイルを送信中...';
                        for (const file of files) {
                            if (file.size > maxBytes) {
                                uploadStatusDiv.innerHTML += `<div style="color:#e74c3c;">${file.name} はサイズ上限を超えています (${Math.round(file.size/1024)} KB)</div>`;
                                continue;
                            }
                            const statusLine = document.createElement('div'); statusLine.textContent = `${file.name} を送信中...`; uploadStatusDiv.appendChild(statusLine);
                            // if file is larger than chunkSize, use chunked upload via HTTP POST
                            if (file.size > chunkSize) {
                                // generate a unique upload id
                                const uploadId = `${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`;
                                const totalChunks = Math.ceil(file.size / chunkSize);
                                for (let idx = 0; idx < totalChunks; idx++) {
                                    const start = idx * chunkSize;
                                    const end = Math.min(start + chunkSize, file.size);
                                    const blob = file.slice(start, end);
                                    const form = new FormData();
                                    form.append('upload_id', uploadId);
                                    form.append('chunk_index', idx);
                                    form.append('total_chunks', totalChunks);
                                    form.append('filename', file.name);
                                    form.append('room', currentRoom);
                                    form.append('chunk', blob, `${file.name}.part${idx}`);
                                    try {
                                        const resp = await fetch('/upload_chunk', { method: 'POST', body: form });
                                        const j = await resp.json().catch(()=>({status:'error', reason:'invalid json'}));
                                        if (!resp.ok || j.status !== 'ok') {
                                            statusLine.textContent = `${file.name} の送信中にエラーが発生しました: ${j.reason || resp.statusText}`;
                                            break;
                                        }
                                    } catch (err) {
                                        statusLine.textContent = `${file.name} の送信中にエラーが発生しました: ${err}`;
                                        break;
                                    }
                                    statusLine.textContent = `${file.name} を送信中... (${idx+1}/${totalChunks})`;
                                }
                                statusLine.textContent = `${file.name} の送信完了（サーバーで処理中）`;
                            } else {
                                // small file: use existing base64 Socket.IO path
                                const reader = new FileReader();
                                reader.onload = function(e) {
                                    socket.emit('send_message', { 'file': { 'name': file.name, 'data': e.target.result }, 'room': currentRoom });
                                };
                                reader.readAsDataURL(file);
                            }
                        }
                        // 送信後に選択表示をクリア
                        fileInput.value = '';
                        document.getElementById('selected-files').innerHTML = '';
                }
                messageInput.focus();
            });
            // 選択ファイル名を表示
            fileInput.addEventListener('change', function(e) {
                const listDiv = document.getElementById('selected-files');
                listDiv.innerHTML = '';
                const files = Array.from(e.target.files || []);
                if (files.length === 0) {
                    document.getElementById('file-help-text').textContent = 'ファイルを添付するには「+」をクリックしてファイルを選択し、選択後に「送信」を押してください。 (同時に送れるのは最大3件)';
                    return;
                }
                const ul = document.createElement('ul');
                ul.style.margin = '4px 0 0 16px';
                ul.style.padding = '0';
                files.forEach(function(f) {
                    const li = document.createElement('li');
                    li.textContent = `${f.name} (${Math.round(f.size/1024)} KB)`;
                    li.style.listStyle = 'disc';
                    li.style.marginBottom = '4px';
                    ul.appendChild(li);
                });
                listDiv.appendChild(ul);
                document.getElementById('file-help-text').textContent = 'ファイルを選択しました。送信ボタンを押してアップロードしてください。';
            });
            messageInput.addEventListener('input', function() { socket.emit('typing', { 'username': currentUser, 'room': currentRoom }); });
        }

        // follow/unfollow button handlers with immediate UI update
        async function setButtonState(btnContainer, username) {
            try {
                const res = await fetch(`/is_following?username=${encodeURIComponent(username)}`);
                const j = await res.json();
                const following = !!j.following;
                const followBtn = btnContainer.querySelector('.follow-btn');
                const unfollowBtn = btnContainer.querySelector('.unfollow-btn');
                if (following) {
                    followBtn.style.display = 'none'; unfollowBtn.style.display = 'inline-block';
                } else {
                    followBtn.style.display = 'inline-block'; unfollowBtn.style.display = 'none';
                }
            } catch(e) { }
        }

        document.addEventListener('click', function(e) {
            if (e.target.matches('.follow-btn')) {
                const u = e.target.dataset.username;
                const container = e.target.closest('.history-item');
                fetch('/follow', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: `username=${encodeURIComponent(u)}` })
                    .then(r=>r.json()).then(j => {
                        if (j.status==='ok') {
                            // update UI
                            const followBtn = container.querySelector('.follow-btn');
                            const unfollowBtn = container.querySelector('.unfollow-btn');
                            if (followBtn) followBtn.style.display='none';
                            if (unfollowBtn) unfollowBtn.style.display='inline-block';
                        } else { showToast('エラー: '+j.reason, 'error'); }
                    }).catch(e=>showToast(String(e), 'error'));
            }
            if (e.target.matches('.unfollow-btn')) {
                const u = e.target.dataset.username;
                const container = e.target.closest('.history-item');
                fetch('/unfollow', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: `username=${encodeURIComponent(u)}` })
                    .then(r=>r.json()).then(j => {
                        if (j.status==='ok') {
                            const followBtn = container.querySelector('.follow-btn');
                            const unfollowBtn = container.querySelector('.unfollow-btn');
                            if (followBtn) followBtn.style.display='inline-block';
                            if (unfollowBtn) unfollowBtn.style.display='none';
                            // if show_all not set, remove history item to reflect default "follow-only" view
                            const urlParams = new URLSearchParams(window.location.search);
                            if (urlParams.get('show_all') !== '1') {
                                container.remove();
                            }
                        } else { showToast('エラー: '+j.reason, 'error'); }
                    }).catch(e=>showToast(String(e), 'error'));
            }
        });

        // initialize follow button states for existing history items
        document.querySelectorAll('.history-item').forEach(item => {
            const username = item.textContent.trim().split('\n')[0].trim();
            // find the button container area we added inside server-rendered markup
            const btnContainer = item.querySelector('div');
            if (btnContainer) setButtonState(btnContainer, username);
        });

        // Unified renderMessage: safe handling + HTML escaping + file rendering
        function renderMessage(msg) {
            const chatWindow = document.getElementById('chat-window');
            if (!chatWindow) return;
            const side = msg.username === currentUser ? 'mine' : 'other';
            let contentHtml = '';
            if (msg.message) {
                contentHtml = ('' + msg.message).replace(/</g, '&lt;').replace(/>/g, '&gt;');
            } else if (msg.file_path) {
                if (msg.file_type === 'image') contentHtml = `<img src="/uploads/${msg.file_path}" alt="画像">`;
                else if (msg.file_type === 'video') contentHtml = `<video src="/uploads/${msg.file_path}" controls></video>`;
                else if (msg.file_type === 'pdf') contentHtml = `<a href="/uploads/${msg.file_path}" target="_blank">📄 [PDFファイル: ${msg.file_path}]</a>`;
            }
            const ts = msg.timestamp_formatted || (msg.timestamp ? new Date(msg.timestamp).toLocaleString('ja-JP') : '');
            const safeClass = (typeof msg.safe !== 'undefined' && msg.safe === 0) ? ' unsafe-message' : '';
            const html = `<div class="message ${side}"><div class="message-bubble${safeClass}"><div class="message-content">${contentHtml}</div></div><div class="message-info"><span class="username">${(msg.username||'').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span> - <span class="timestamp">${ts}</span></div></div>`;
            chatWindow.insertAdjacentHTML('beforeend', html);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }
        
        const copyBtn = document.getElementById('copy-invite-link-btn');
        const inviteLinkInput = document.getElementById('invite-link-input');
        copyBtn.addEventListener('click', function() { inviteLinkInput.select(); navigator.clipboard.writeText(inviteLinkInput.value).then(function() { copyBtn.textContent = 'コピーしました！'; setTimeout(function() { copyBtn.textContent = 'リンクをコピー'; }, 2000); }, function(err) { console.error('クリップボードへのコピーに失敗しました: ', err); }); });
        
        function updateOnlineUsersDisplay(users) {
            // legacy compatibility: this function still renders, but prefer using refreshOnlineStatus to populate
            const onlineListDiv = document.getElementById('online-users-list');
            if (!onlineListDiv) return;
            const isAdmin = document.getElementById('current-user') && document.getElementById('current-user').dataset.isAdmin === '1';
            // admins always see full online list
            if (isAdmin) {
                onlineListDiv.innerHTML = '';
                const list = (ONLINE_STATUS_CACHE.online && ONLINE_STATUS_CACHE.online.length) ? ONLINE_STATUS_CACHE.online : users;
                (list || []).forEach(function(user) {
                    if (user !== currentUser) {
                        const userEl = document.createElement('div');
                        userEl.textContent = `🟢 ${user}`;
                        onlineListDiv.appendChild(userEl);
                    }
                });
                return;
            }
            // non-admins: use selected filter
            applyOnlineFilterAndRender();
        }

        function applyOnlineFilterAndRender() {
            const onlineListDiv = document.getElementById('online-users-list');
            if (!onlineListDiv) return;
            // determine filter from active button or URL param
            const filterContainer = document.getElementById('online-filter');
            let filter = 'followers';
            if (filterContainer) {
                const activeBtn = filterContainer.querySelector('.online-filter-btn.active');
                filter = (activeBtn && activeBtn.dataset && activeBtn.dataset.filter) ? activeBtn.dataset.filter : (new URLSearchParams(window.location.search).get('filter') || 'followers');
            }
            const { online, followers, following } = ONLINE_STATUS_CACHE || { online: [], followers: [], following: [] };
            let displayUsers = [];
            if (filter === 'followers') {
                displayUsers = (followers || []).filter(u => (online || []).includes(u));
            } else if (filter === 'following') {
                displayUsers = (following || []).filter(u => (online || []).includes(u));
            } else {
                displayUsers = (online || []).filter(u => u !== currentUser);
            }
            if (displayUsers.length === 0) {
                onlineListDiv.innerHTML = '<div style="color:#fff;">該当ユーザーはいません</div>';
                return;
            }
            onlineListDiv.innerHTML = '';
            displayUsers.forEach(function(user) {
                const userEl = document.createElement('div'); userEl.textContent = `🟢 ${user}`; onlineListDiv.appendChild(userEl);
            });
        }

        // filter buttons initialized in initFilterButtons()

        // initial fetch on load
        refreshOnlineStatus();
        // Rebuild partner_select options based on filter choice.
        function updatePartnerSelect(users) {
            const partnerSelect = document.getElementById('partner_select');
            if (!partnerSelect) return;
            // remove all options except the placeholder (first option)
            const placeholder = partnerSelect.options[0] ? partnerSelect.options[0].value : '';
            partnerSelect.innerHTML = '';
            const placeholderEl = document.createElement('option'); placeholderEl.value = ''; placeholderEl.textContent = '-- 会話相手を選択 --'; partnerSelect.appendChild(placeholderEl);

            // Determine which users to include based on current filter
            const filterEl = document.getElementById('online-filter');
            const activeFilter = (filterEl && filterEl.querySelector('.online-filter-btn.active')) ? filterEl.querySelector('.online-filter-btn.active').dataset.filter : (new URLSearchParams(window.location.search).get('filter') || 'followers');
            let candidates = [];
            if (activeFilter === 'all') {
                candidates = users;
            } else if (activeFilter === 'following') {
                candidates = (ONLINE_STATUS_CACHE.following || []).filter(u => (users || []).includes(u));
            } else {
                // followers
                candidates = (ONLINE_STATUS_CACHE.followers || []).filter(u => (users || []).includes(u));
            }

            // fallback: if candidates empty, use provided users param
            if (!candidates || candidates.length === 0) candidates = users || [];

            candidates.forEach(user => {
                if (user !== currentUser) {
                    const option = document.createElement('option'); option.value = user; option.textContent = user; partnerSelect.appendChild(option);
                }
            });
        }

        // filter button handling: toggle active state and persist to URL
        (function initFilterButtons(){
            const container = document.getElementById('online-filter');
            if (!container) return;
            // read from URL param first
            const urlParams = new URLSearchParams(window.location.search);
            const initial = urlParams.get('filter') || 'followers';
            const buttons = Array.from(container.querySelectorAll('.online-filter-btn'));
            function setActive(filter, pushState=true){
                buttons.forEach(b => {
                    const isActive = (b.dataset.filter === filter);
                    b.classList.toggle('active', isActive);
                    b.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                });
                // update URL query param
                if (pushState) {
                    urlParams.set('filter', filter);
                    const newUrl = `${location.pathname}?${urlParams.toString()}`;
                    history.replaceState(null, '', newUrl);
                }
                applyOnlineFilterAndRender();
                // rebuild partner select based on new filter and current online list
                updatePartnerSelect(ONLINE_STATUS_CACHE.online || []);
            }
            buttons.forEach(b => {
                b.addEventListener('click', (ev)=>{ setActive(b.dataset.filter); });
                b.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); b.click(); } });
            });
            setActive(initial, false);
        })();

        // partner source selector (online / history / all)
        (function initPartnerSource(){
            const srcContainer = document.getElementById('partner-source');
            if (!srcContainer) return;
            const buttons = Array.from(srcContainer.querySelectorAll('.online-filter-btn'));
            function setActiveSource(src){
                buttons.forEach(b => {
                    const isActive = (b.dataset.source === src);
                    b.classList.toggle('active', isActive);
                    b.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                });
                // build candidates
                if (src === 'online') {
                    updatePartnerSelect(ONLINE_STATUS_CACHE.online || []);
                } else if (src === 'history') {
                    // extract usernames from server-rendered history list
                    const historyUsers = Array.from(document.querySelectorAll('#history-list .history-item')).map(el => el.textContent.trim().split('\n')[0].trim()).filter(Boolean);
                    updatePartnerSelect(historyUsers);
                } else if (src === 'all') {
                    // fetch admin-only users list
                    fetch('/users_list').then(r => r.json()).then(j => {
                        if (j && j.users) updatePartnerSelect(j.users);
                    }).catch(e => { console.error('users_list fetch failed', e); updatePartnerSelect([]); });
                }
            }
            buttons.forEach(b => {
                b.addEventListener('click', (ev)=>{ setActiveSource(b.dataset.source); });
                b.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); b.click(); } });
            });
            // default to 'online'
            setActiveSource('online');
        })();
        // Sidebar toggle for small screens
        (function initSidebarToggle(){
            const toggle = document.getElementById('sidebar-toggle');
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            if (!toggle || !sidebar || !overlay) return;
            function openSidebar(){ sidebar.classList.add('open'); overlay.classList.add('visible'); document.body.classList.add('mobile-sidebar-open'); toggle.setAttribute('aria-label','サイドバーを閉じる'); }
            function closeSidebar(){ sidebar.classList.remove('open'); overlay.classList.remove('visible'); document.body.classList.remove('mobile-sidebar-open'); toggle.setAttribute('aria-label','サイドバーを開く'); }
            toggle.addEventListener('click', ()=>{ if (sidebar.classList.contains('open')) closeSidebar(); else openSidebar(); });
            overlay.addEventListener('click', closeSidebar);
            document.addEventListener('keydown', (ev)=>{ if (ev.key === 'Escape' && sidebar.classList.contains('open')) closeSidebar(); });
            // show toggle only on small screens
            function adjustToggleVisibility(){ if (window.innerWidth <= 900) { toggle.style.display='inline-block'; } else { toggle.style.display='none'; closeSidebar(); } }
            window.addEventListener('resize', adjustToggleVisibility); adjustToggleVisibility();
        })();
    });
</script>
</body>
</html>